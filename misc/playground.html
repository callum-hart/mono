<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>

<form class="BASE_FORM">base form</form>

<form class="BASE_FORM BASE_FORM--WITH_ERROR">base form with error</form>

<h1>Heading</h1>

<p class="first-name">Callum</p>

<a href="" class="some-link">Some link</a>

<div class="row">
    <p>Normal text</p>
</div>

<div class="row row--active">
    <p>Active text</p>
</div>

<ul>
    <li class="inherited-property">
        <span>foo</span>
        bar
    </li>
</ul>

<style>
    li.inherited-property {
        font-size: 10px;
        font-size: 15px;
        font-size: 20px; /* font-size inherited by all child elements */
    }
</style>

<style>
    /*
        - Negation removes affects of the cascade - the order of declarations doesn't matter.
        - Which makes declarations more portable and predictable.

        Test case: text in a row is blue, text in an active row is green.

        Without negation, the overriding declaration only wins if:

        - It is declared after the style it's overriding
        - Or, it has a selector with a higher specificity

        This works (declared after):

        .row p {
            color: blue;
        }

        .row--active p {
            color: green;
        }

        This works (higher specificity):

        div.row--active p {
            color: green;
        }

        .row p {
            color: blue;
        }

        This doesn't work (declared before + equal specificity):

        .row--active p {
            color: green;
        }

        .row p {
            color: blue;
        }

        With negation we needn't bother about cascasde position or selector
        specificity, since there is only one source of truth for each state.

        As expected this works (declared after + equal specificity):

        .row:not(.row--active) p {
            color: blue;
        }

        .row--active p {
            color: green;
        }

        As does this (declared before + equal specificity):

        .row--active p {
            color: green;
        }

        .row:not(.row--active) p {
            color: blue;
        }

        Removing the override has bought us portability and predictability.
        I can gaurentee that text in a row is blue, and text in an active
        row is green. I no longer have to think about the order of declarations
        and the strength of their selector.

        This is super powerful! Negation has removed 2 painpoints of CSS: the
        cascade and selector specificity, which just leaves the styles to
        worry about :)

    */

    .row--active p {
        color: green;
    }

    .row:not(.row--active) p {
        color: blue;
    }
</style>

<style>
    /*
    Using `:not()` pseudo class only sets `background` once (even when form has both classes).
    */
    .BASE_FORM:not(.BASE_FORM--WITH_ERROR) {
        background: grey;
    }

    .BASE_FORM--WITH_ERROR {
        background: red;
    }

    /*
    Color property of `h1` is immutable.
    */
    h1 {
        COLOR: red;
    }

    /*
    If `.first-name` doesn't mutate any immutable properties of `<p>` build tool can trim `<p>` off selector,
    Otherwise throw error.
    */
    .first-name<p> {
        color: blue;
    }

    /*
    Color property of `.some-link` is protected. Which means only pseudo classes can modify it.
    */
    .some-link {
        Color: green;
    }

    .some-link:hover {
        color: orange; /* allowed because `:hover` is a pseudo class */
    }

    /*.some-link {
        color: red;  throws error because `color` of `some-link` can only be modified by pseudo classes
    }*/

</style>

</body>
</html>