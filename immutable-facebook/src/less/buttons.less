
// Put common styles in `.BTN()` mixin --

.BTN(@background, @color) {
    .immutable(PADDING, 4px 8px);
    .protected(Background, @background);

    &when(iscolor(@color)) {
        .protected(Color, @color);
    }

    &:hover {
        .override(Background, darken(@background, 20%));

        &when(iscolor(@color)) {
            .override(Color, blue);
        }
    }
}

// Button variables --

@BTN_PRIMARY_BG: #4962a4;
@BTN_SECONDARY_BG: #eff0f2;

@BTN_PRIMARY_COLOR: #fff;
@BTN_SECONDARY_COLOR: #19191b;

// Button classes --

.btn-primary {
    .BTN(@BTN_PRIMARY_BG, @BTN_PRIMARY_COLOR);
}

.btn-secondary {
    .BTN(@BTN_SECONDARY_BG, @BTN_SECONDARY_COLOR);

    @somevar: blue;

    .foo({
       color: darken(@somevar, 20%) @debug;
       padding: 4px 10px @debug;
    });

    .bar({
       font-size: 12px @debug;
       line-height: 13px @debug;
    });

    /*
    Can now use LESS functions (rather than mixins)
    (For now) can't use variables or functions inside ruleset, i.e can't do:

    @color: red;

    immutable({
        color: darken(@color, 10%);
    })

    This can be done with mixins:

    .immutable(color, darken(@color, 10%));

    .foo({
        color: darken(@color, 10%);
    })
    */

    // bar(#ffffff);

    // immutable({
    //     color: red;
    // });

    // protected({
    //     font-style: italic;
    //     font-size: 20px;
    //     line-height: 20px;
    // });
}

.btn-secondary--with-icon {
    // @color null because we don't want icon to inherit color
    .BTN(@BTN_SECONDARY_BG, null);

    .btn-secondary__text {
        .public(Color, @BTN_SECONDARY_COLOR);
    }

    &:hover {
        // We can modify color of text because its `color` access modifier is public
        .btn-secondary__text {
            .mutate(Color, blue);
        }

        // We can modify color of icon because its `color` access modifier is public
        .icon-primary {
            .mutate(cOlor, red);
        }
    }
}