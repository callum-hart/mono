/**
    Patterns --

    Document patterns used in immutable CSS
*/


/**
    @technique: Negation
    @description: Negation uses the :not pseudo-class to avoid
    mutations amongst composable classes. A common example of
    a composable class is a BEM modifier.
    @problem:

    .form {
        background: grey;
    }

    .form--withError {
        background: red;
    }

    When the form has both classes the background is set twice.
    This breaks the principles enforced by some types, e.g:

    .form {
        background: Immutable(grey);
    }

    The background of `.form` is locked. When the form has the error
    class it cannot change the background property.

    @solution:

    .form:not(.form--withError) {
        background: grey;
    }

    .form--withError {
        background: red;
    }

    @more

    Negation removes affects of the cascade - the order of declarations
    doesn't matter. Which makes declarations more portable and predictable.

    Test case: text in a row is blue, text in an active row is green:

    <div class="row">
        <p>Normal text</p>
    </div>

    <div class="row row--active">
        <p>Active text</p>
    </div>

    Without negation, the overriding declaration only wins if:
    (list ordered by weight).

    - Importance - property is flagged as !important
    - Specificity - it has a selector with a higher specificity
    - Order - it is declared after the style it's overriding

    Todo: add importance example, and order examples by weight...

    This works (declared after):

    .row p {
        color: blue;
    }

    .row--active p {
        color: green;
    }

    This works (higher specificity):

    div.row--active p {
        color: green;
    }

    .row p {
        color: blue;
    }

    This doesn't work (declared before + equal specificity):

    .row--active p {
        color: green;
    }

    .row p {
        color: blue;
    }

    With negation we needn't bother about cascasde position or selector
    specificity, since there is only one source of truth for each state.

    As expected this works (declared after + equal specificity):

    .row:not(.row--active) p {
        color: blue;
    }

    .row--active p {
        color: green;
    }

    As does this (declared before + equal specificity):

    .row--active p {
        color: green;
    }

    .row:not(.row--active) p {
        color: blue;
    }

    Removing the override has bought us portability and predictability.
    I can gaurentee that text in `row` is blue, and text in `row--active`
    is green. I no longer have to think about the order of declarations
    and the strength of their selector.

    This is super powerful! Negation has removed 2 painpoints of CSS: the
    cascade and selector specificity, which just leaves the styles to
    worry about :)

*/

/**
    @technique: Selector types
    @description: Selectors should include their element type.
    This has several benefits:

    *Note: a consumer is an element or group of elements which CSS
    rules are applied.

    - Improved scoping – styles are scoped to the elements that use them.
    - Encapsulation – styles are brought out of the global domain.
    - Better visibility – reduces ambiguity of consumers.
    - Reduces conflicts – easier to avoid and track unwanted overides.

    @problem:

    .title {
        font-size: 20px;
    }

    The `.title` class is obscure. We cannot make any guarantee of
    who the consumer is. And we have no control (or foresight) over
    what other styles will be applied.

    As it stands our title does not have a predictable or concrete
    shape. For example:

    <span class="title"></span>
    <h1 class="title"></h1>

    Both instances of `.title` will look different.

    @solution:

    h1.title {
        font-size: 20px;
    }

*/

/**
    @technique: Breakpoint encapsulation
    @description: Properties whose values change at different
    screensizes should be scoped within breakpoints.
    @problem:

    .foo {
        font-size: 14px;
    }

    @media(min-width: 500px) {
        .foo {
            font-size: 12px;
        }
    }

    On screens wider than 500px the font-size of `.foo` is set twice.
    This breaks the principles enforced by some types, e.g:

    .foo {
        font-size: Immutable(14px);
    }

    The font-size of `.foo` is locked. It cannot be changed inside the
    media query.

    @solution:

    @media(max-width: 500px) {
        .foo {
            font-size: 14px;
        }
    }

    @media(min-width: 500px) {
        .foo {
            font-size: 12px;
        }
    }

    Could seperate styles into files?

    ├── nav
    |   └── nav.scss (common styles used accross breakpoints)
    |   └── nav--desktop.css
    |   └── nav--tablet.css
    |   └── nav--mobile.css

*/

/**
    @technique: Shorthand appropriately
    @description: Use shorthand notation only when a property has
    multiple values.

    @problem:

    div.pow {
        margin: 10px 0 0 0;
    }

    nav div.pow {
        margin: 10px 0 0 10px;
    }

    The top margin of `.pow` is concrete (it should always be 10px).
    With shorthand: future changes to margin sides of `.pow` must
    hydrate concrete values by duplicating their assignment.

    Inside `nav` the top margin is re-applyed even though only the
    left margin is changed.

    - Accidental mutations: easy to unintentionally override concrete
      values.
    - Unnecessary: we can leverage browser defaults, default margins
      are already 0.
    - Obfuscates values: cannot gaurentee hydrated values without
      looking at their initial assignment.
    - Increases risk of breaking principles, e.g:

    div.pow {
        margin: Immutable(10px 0 0 0);
    }

    All margin sides of `.pow` are locked. The top/right/bottom/left margins
    cannot be changed.

    @solution

    div.pow {
        margin-top: Immutable(10px);
    }

    nav div.pow {
        margin-left: 10px;
    }

    *Aside: improves readability since the property name describes
    where the value is applied.

*/

/**
    @technique: Universal objects
    @description: Styles that are decoupled from their context.
    Always look the same regardless of where they are used.
    @problem:

    - CSS classes are too brittle.
    - No seperation between universal and contextual styles.
    - Easy to accidentally override universal styles.

    todo: add code examples

    @solution:

    - Encapsulate universal styles with a universal class (i.e *box)
    - Add contextual styles with a universal identifier class (i.e story-*box)

    class="*box story-*box"

    todo: add code examples

*/